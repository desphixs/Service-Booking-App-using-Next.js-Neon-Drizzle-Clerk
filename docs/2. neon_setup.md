## Step 1: Neon Database Setup

1. Log in to the [Neon Console](https://console.neon.tech).
2. Create a new project (e.g., `service-booking-app`).
3. Copy your **Connection String** (it starts with `postgresql://...`).
4. In your project root, create a `.env.local` file:

```env
DATABASE_URL=postgresql://user:password@your-neon-host/neondb?sslmode=require

```

---

## Step 2: Install Dependencies

Run the following command to install the Drizzle core, the Neon serverless driver, and the necessary development tools:

```bash
npm install drizzle-orm @neondatabase/serverless
npm install -D drizzle-kit dotenv

```

---

## Step 3: Directory Structure

Organize your database files within a dedicated `db` folder for clarity:

```text
src/ (or root)
└── db/
    ├── schema.ts      <-- Tables and Relationships
    ├── index.ts       <-- Connection setup
    └── drizzle.config.ts <-- Migration settings (placed in root)

```

---

## Step 4: Define Schemas & Relationships

In **2025**, it is best practice to keep schemas modular. Note the use of `jsonb` for arrays like `included` and `timeSlots`, as standard PostgreSQL arrays can be less flexible with Drizzle.

**File:** `db/schema.ts`

```typescript
import { pgTable, text, integer, timestamp, boolean, uuid, varchar, jsonb } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// --- Customers Table ---
export const customers = pgTable("customers", {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id").notNull().unique(), // Clerk User ID
    email: varchar("email", { length: 255 }).notNull(),
    fullName: text("full_name").notNull(),
    phone: varchar("phone", { length: 20 }),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// --- Services Table ---
export const services = pgTable("services", {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id").notNull(), // Owner/Provider ID
    image: text("image"),
    title: text("title").notNull(),
    slug: text("slug").notNull().unique(),
    description: text("description"),
    category: varchar("category", { length: 100 }),
    included: jsonb("included").$type<string[]>(), // Array of perks
    timeSlots: jsonb("time_slots").$type<string[]>(), // Available times
    price: integer("price").notNull(), // stored in cents
    currency: varchar("currency", { length: 10 }).default("NGN"),
    durationMinutes: integer("duration_minutes").default(60),
    isActive: boolean("is_active").default(true),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// --- Bookings Table ---
export const bookings = pgTable("bookings", {
    id: text("id").primaryKey(), // Using your "bkg_..." format
    serviceId: uuid("service_id").references(() => services.id, { onDelete: "cascade" }),
    customerId: uuid("customer_id").references(() => customers.id),
    serviceTitle: text("service_title").notNull(),
    scheduledFor: timestamp("scheduled_for").notNull(),
    amount_paid: integer("amount"),
    stripeCheckoutSessionId: text("stripe_checkout_session_id"),
    stripePaymentIntentId: text("stripe_payment_intent_id"),
    timezone: text("timezone").default("Africa/Lagos"),
    status: varchar("status", { length: 20 }).default("pending"), // paid, failed, pending
    notes: text("notes"),
    createdAt: timestamp("created_at").defaultNow().notNull(),
    updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// --- Relationships ---
export const customerRelations = relations(customers, ({ many }) => ({
    bookings: many(bookings),
}));

export const bookingRelations = relations(bookings, ({ one }) => ({
    service: one(services, {
        fields: [bookings.serviceId],
        references: [services.id],
    }),
    customer: one(customers, {
        fields: [bookings.customerId],
        references: [customers.id],
    }),
}));
```

---

## Step 5: Database Connection

Initialize the Neon HTTP driver. This is optimized for serverless environments like Vercel.

**File:** `db/index.ts`

```typescript
import { neon } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-http";
import * as schema from "./schema";

const sql = neon(process.env.DATABASE_URL!);
export const db = drizzle(sql, { schema });
```

---

## Step 6: Drizzle Configuration

This file tells Drizzle where to look for your schema and where to save migration files.

**File:** `drizzle.config.ts` (Project Root)

```typescript
import { defineConfig } from "drizzle-kit";
import * as dotenv from "dotenv";

dotenv.config({ path: ".env.local" });

export default defineConfig({
    schema: "./db/schema.ts",
    out: "./drizzle",
    dialect: "postgresql",
    dbCredentials: {
        url: process.env.DATABASE_URL!,
    },
});
```

---

## Step 7: Generate & Push Migrations

In 2025, there are two primary ways to update your database.

### Option A: Local Migrations (Recommended for Production)

This generates SQL files that you can keep in version control.

1. **Generate:** `npx drizzle-kit generate`
2. **Migrate:** `npx drizzle-kit migrate`

### Option B: Quick Prototyping (Recommended for Development)

This pushes your schema directly to Neon without creating SQL files.

-   **Push:** `npx drizzle-kit push`

---

## Step 8: Adding Scripts to package.json

Add these to your `package.json` to make life easier:

```json
"scripts": {
  "db:generate": "drizzle-kit generate --config=db/drizzle.config.ts",
        "db:migrate": "drizzle-kit migrate --config=db/drizzle.config.ts",
        "db:push": "drizzle-kit push --config=db/drizzle.config.ts",
        "db:studio": "drizzle-kit studio --config=db/drizzle.config.ts"
}

```

> **Pro Tip:** Use `npm run db:studio` to open a local browser-based GUI to view and edit your Neon data directly.
